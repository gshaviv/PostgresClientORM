{"schemaVersion":{"minor":3,"patch":0,"major":0},"kind":"article","hierarchy":{"paths":[["doc:\/\/PostgresClientORM\/documentation\/PostgresClientORM"]]},"primaryContentSections":[{"kind":"content","content":[{"level":2,"type":"heading","anchor":"Overview","text":"Overview"},{"inlineContent":[{"inlineContent":[{"type":"text","text":"PostgresClientORM"}],"type":"strong"},{"type":"text","text":" is an "},{"type":"strong","inlineContent":[{"type":"text","text":"ORM"}]},{"text":" for storing objects in Postgres. It uses the package ","type":"text"},{"type":"emphasis","inlineContent":[{"text":"PostgresNIO","type":"text"}]},{"type":"text","text":" for the connection to Postgres. "},{"type":"strong","inlineContent":[{"text":"PostgresClientORM","type":"text"}]},{"type":"text","text":" has the advantage over "},{"type":"strong","inlineContent":[{"text":"Fluent","type":"text"}]},{"text":" that it’s more Swift friendly, faster, and has a lower memory footprint for loaded objects. The advantage of Fluent us that it’s database agnostic.","type":"text"}],"type":"paragraph"},{"text":"Connection","level":3,"type":"heading","anchor":"Connection"},{"type":"paragraph","inlineContent":[{"type":"text","text":"The connection to "},{"type":"strong","inlineContent":[{"type":"text","text":"Postgres"}]},{"text":" database is controlled via environment variables. If the environment ","type":"text"},{"type":"strong","inlineContent":[{"text":"DATABASE_URL","type":"text"}]},{"type":"text","text":" exists, it is used to control the connection, otherwise the set of following enviroment variables is used:"}]},{"type":"unorderedList","items":[{"content":[{"type":"paragraph","inlineContent":[{"inlineContent":[{"type":"text","text":"DATABASE_HOST"}],"type":"strong"}]}]},{"content":[{"inlineContent":[{"inlineContent":[{"type":"text","text":"DATABASE_PORT"}],"type":"strong"},{"text":" (defaults to 5432 if not present)","type":"text"}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"strong","inlineContent":[{"text":"DATABASE_USER","type":"text"}]}]}]},{"content":[{"inlineContent":[{"type":"strong","inlineContent":[{"type":"text","text":"DATABASE_PASSWORD"}]}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"inlineContent":[{"type":"text","text":"DATABASE_SSL"}],"type":"strong"},{"text":" (defaults to true if not present)","type":"text"}]}]}]},{"inlineContent":[{"text":"If using in ","type":"text"},{"inlineContent":[{"text":"VAPOR","type":"text"}],"type":"strong"},{"type":"text","text":" you need to connect "},{"inlineContent":[{"type":"text","text":"PostresClientORM"}],"type":"strong"},{"type":"text","text":" to the app event loop, and optionally to the logger. So early in your configure function (before any database access) do:"}],"type":"paragraph"},{"code":["PostgresClientORM.configure(logger: app.logger, eventLoop: app.eventLoopGroup.next())"],"syntax":"swift","type":"codeListing"},{"inlineContent":[{"type":"text","text":"The logger parameter is optional, ommitting it will cause "},{"type":"strong","inlineContent":[{"text":"PostgresClientORM","type":"text"}]},{"text":" to create it’s own logger.","type":"text"}],"type":"paragraph"},{"level":3,"type":"heading","anchor":"Models","text":"Models"},{"inlineContent":[{"type":"text","text":"To create models use the "},{"type":"codeVoice","code":"@TableObject"},{"text":" macro. Example:","type":"text"}],"type":"paragraph"},{"code":["@TableObject(table: \"weather\", idType: UUID.self)","struct Weather {","  var city: String","  var tempLo: Int","  var tempHi: Int","}"],"type":"codeListing","syntax":"Swift"},{"inlineContent":[{"type":"text","text":"Models can be a "},{"code":"struct","type":"codeVoice"},{"type":"text","text":" or a "},{"type":"codeVoice","code":"final class"},{"text":". The macro makes the object conform to the ","type":"text"},{"type":"reference","isActive":true,"identifier":"doc:\/\/PostgresClientORM\/documentation\/PostgresClientORM\/TableObject"},{"text":" protocol. The macro accepts the following parameters:","type":"text"}],"type":"paragraph"},{"header":"row","type":"table","alignments":["unset","center","unset"],"rows":[[[{"type":"paragraph","inlineContent":[{"type":"text","text":"Parameter"}]}],[{"type":"paragraph","inlineContent":[{"text":"Default\/Required","type":"text"}]}],[{"inlineContent":[{"text":"Explanation","type":"text"}],"type":"paragraph"}]],[[{"inlineContent":[{"type":"text","text":"columns:"}],"type":"paragraph"}],[{"type":"paragraph","inlineContent":[{"type":"text","text":".snakeCase"}]}],[{"inlineContent":[{"type":"codeVoice","code":".snakeCase"},{"text":" or ","type":"text"},{"code":".camelCase","type":"codeVoice"},{"type":"text","text":". Cpecifies how the column name is derived."}],"type":"paragraph"}]],[[{"type":"paragraph","inlineContent":[{"type":"text","text":"table:"}]}],[{"type":"paragraph","inlineContent":[{"inlineContent":[{"type":"text","text":"required"}],"type":"strong"}]}],[{"type":"paragraph","inlineContent":[{"text":"The name of the table holding these objects.","type":"text"}]}]],[[{"type":"paragraph","inlineContent":[{"text":"idType:","type":"text"}]}],[{"inlineContent":[{"type":"strong","inlineContent":[{"text":"required","type":"text"}]}],"type":"paragraph"}],[{"type":"paragraph","inlineContent":[{"type":"text","text":"The type of the id column, e.g. "},{"type":"codeVoice","code":"UUID.self"}]}]],[[{"type":"paragraph","inlineContent":[{"type":"text","text":"idName:"}]}],[{"type":"paragraph","inlineContent":[{"text":"“id”","type":"text"}]}],[{"inlineContent":[{"text":"The name of the id column. The id property will alwas be ","type":"text"},{"code":"id","type":"codeVoice"}],"type":"paragraph"}]],[[{"type":"paragraph","inlineContent":[{"type":"text","text":"trackDirty:"}]}],[{"inlineContent":[{"type":"text","text":"true"}],"type":"paragraph"}],[{"inlineContent":[{"type":"codeVoice","code":"true"},{"type":"text","text":" \/ "},{"type":"codeVoice","code":"false"},{"text":" if to keep track if the object is dirty, i.e. changed since it was loaded from the database","type":"text"}],"type":"paragraph"}]],[[{"inlineContent":[{"type":"text","text":"codable:"}],"type":"paragraph"}],[{"inlineContent":[{"type":"text","text":".none"}],"type":"paragraph"}],[{"inlineContent":[{"type":"text","text":"Also make the object Codable, value can be "},{"type":"codeVoice","code":".none"},{"text":"\/","type":"text"},{"code":".snakeCase","type":"codeVoice"},{"type":"text","text":"\/"},{"type":"codeVoice","code":".camelCase"}],"type":"paragraph"}]]]},{"type":"paragraph","inlineContent":[{"text":"The object will have an ","type":"text"},{"type":"codeVoice","code":"id"},{"type":"text","text":" property of type "},{"type":"codeVoice","code":"idType"},{"type":"text","text":" to hold it’s database id."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"if "},{"type":"codeVoice","code":"trackDirty"},{"text":" is ","type":"text"},{"type":"codeVoice","code":"true"},{"text":" (default) the object will conform to ","type":"text"},{"type":"codeVoice","code":"SaveableTableObject"},{"type":"text","text":" and will have the "},{"code":"save()","type":"codeVoice"},{"type":"text","text":" func which will check if the object is dirty, it will update, if the object is new it will insert otherwise it will do nothing. The object will also have a "},{"code":"isDirty()","type":"codeVoice"},{"type":"text","text":" func that will return a bool stating if the object is dirty."}]},{"inlineContent":[{"text":"A good practice is to have an ","type":"text"},{"code":"idType","type":"codeVoice"},{"type":"text","text":" of type "},{"code":"UUID.self","type":"codeVoice"},{"type":"text","text":". In which case "},{"inlineContent":[{"text":"PostgresClientORM","type":"text"}],"type":"strong"},{"text":" knows to set it on it’s own. Autoincremented ids are not yet support (","type":"text"},{"inlineContent":[{"text":"on the todo list","type":"text"}],"type":"emphasis"},{"text":").","type":"text"}],"type":"paragraph"},{"inlineContent":[{"text":"You can set a custom column name for a ","type":"text"},{"type":"codeVoice","code":"var"},{"text":" by prefixing it with the ","type":"text"},{"type":"codeVoice","code":"@Column(name \"custom_name\")"},{"text":" macro. A property can be ignored by prefixing it with the ","type":"text"},{"code":"@ColumnIgnored","type":"codeVoice"},{"type":"text","text":" macro. In a similar manner if you specify in the "},{"type":"codeVoice","code":"@TableObject"},{"text":" macro to also conform to ","type":"text"},{"type":"codeVoice","code":"Codable"},{"type":"text","text":", a custom "},{"code":"CodingKey","type":"codeVoice"},{"type":"text","text":" can be set with "},{"code":"@Coding(key: \"customKey\")","type":"codeVoice"},{"text":" and ignored with ","type":"text"},{"code":"@CodingKeysIgnored","type":"codeVoice"}],"type":"paragraph"},{"level":3,"text":"FieldSubset","anchor":"FieldSubset","type":"heading"},{"type":"paragraph","inlineContent":[{"type":"text","text":"A "},{"code":"FieldSubset","type":"codeVoice"},{"type":"text","text":" is struct that can encode it’s properties together with the it’s parent. For example:"}]},{"syntax":"swift","code":["@TableObject(table: \"weather\", idToype: UUID.self)","struct Weather {","    var city: String","    var temp: TempRange","}","","@Columns","struct TempRange {","    let lo: Double","    let hi: Double","}"],"type":"codeListing"},{"type":"paragraph","inlineContent":[{"text":"This will encode the temp propperty in the column ","type":"text"},{"inlineContent":[{"type":"text","text":"temp_lo"}],"type":"strong"},{"type":"text","text":" and "},{"inlineContent":[{"text":"temp_hi","type":"text"}],"type":"strong"},{"type":"text","text":" of table "},{"inlineContent":[{"type":"text","text":"weather"}],"type":"strong"},{"text":". A ","type":"text"},{"type":"codeVoice","code":"FieldSubset"},{"text":" can also be used to generate manual encoding of a property to the table, use the ","type":"text"},{"type":"codeVoice","code":"Column"},{"type":"text","text":" named "},{"type":"codeVoice","code":"root"},{"type":"text","text":" (string value “”), for example:"}]},{"type":"codeListing","syntax":"swift","code":["enum CityType: FieldSubset {","    case metropolitan","    case village","","    enum Columns: String, CodingKey {","        case root = \"\"","    }","","    init(row: RowDecoder<Columns>) throws {","       let v = try row.decode(Int.self, forKey: .root)","       switch v {","        case 1:","            self = .metropolitan","        default:","            self = .village","       }","    }","","    func encode(row: RowEncoder<Columns>) throws {","        switch self {","            case .metropolitan: ","                try row.encode(1, forKey: .root)","            case .village: ","                try row.encode(2, forKey: .root)","        }","   }","}"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"This is just an example. It is not necessary to declare "},{"code":"RawRepresentable","type":"codeVoice"},{"type":"text","text":" enums as "},{"type":"codeVoice","code":"FieldSet"},{"type":"text","text":" as by default they are and encode their "},{"code":"rawValue","type":"codeVoice"},{"type":"text","text":"."}]},{"level":3,"type":"heading","anchor":"Querying","text":"Querying"},{"type":"paragraph","inlineContent":[{"text":"Create a query with the type functions ","type":"text"},{"type":"codeVoice","code":"select()"},{"text":", ","type":"text"},{"code":"delete()","type":"codeVoice"},{"text":" or ","type":"text"},{"type":"codeVoice","code":"count()"},{"type":"text","text":". Example:"}]},{"syntax":"swift","type":"codeListing","code":["let cities = try await Weather.select()","    .where {","        Weather.column(.temp) -› TempRange.column(.lo) > 0","        Weather.column(.temp) -› TempRange.column(.hi) < 35","    }","    .limit(20)","    .execute()"]},{"type":"heading","level":4,"text":"Explanation:","anchor":"Explanation"},{"inlineContent":[{"text":"the ","type":"text"},{"code":".where { ... }","type":"codeVoice"},{"text":" is used to set SQL where conditions. By default the conditions are merged using the AND operator. You can place conditions in an ","type":"text"},{"code":"Or { ... }","type":"codeVoice"},{"text":" block to have them grouped with the OR operator. The ","type":"text"},{"type":"codeVoice","code":"-›"},{"type":"text","text":" operator (the › is generated by option-shift-4) is used for columns of a "},{"type":"codeVoice","code":"FieldSubset"},{"text":", so ","type":"text"},{"code":"Weather.column(.temp) -› TempRange.column(.lo) > 0","type":"codeVoice"},{"type":"text","text":" resolves to the column named "},{"type":"codeVoice","code":"temp_lo"},{"text":". The ","type":"text"},{"code":"count()","type":"codeVoice"},{"text":" query return value is just an ","type":"text"},{"type":"strong","inlineContent":[{"type":"text","text":"Int"}]},{"text":" of the count of items found.","type":"text"}],"type":"paragraph"},{"level":4,"anchor":"Result-Sequence","type":"heading","text":"Result Sequence"},{"inlineContent":[{"type":"text","text":"In the above example, "},{"type":"codeVoice","code":"cities"},{"type":"text","text":" if an array of the results of type "},{"type":"codeVoice","code":"[Weather]"},{"type":"text","text":". A more optimal approach is to use a result sequence, this will fetch the SQL results row by row and decode them a row at a time, not storing all the results in memroy. Example:"}],"type":"paragraph"},{"code":["let query = try Weather.select().where {","    Weather.column(.city) =* \"N\" \/\/ the =* operator uses the SQL LIKE operator to find strings with the N prefix. ","                                 \/\/ Similar operators are *= and *=* for suffix and contains respectively.","}","for try await city in query.results {","    ... \/\/ do something with a city","}"],"type":"codeListing","syntax":"swift"},{"level":3,"text":"Migrations","type":"heading","anchor":"Migrations"},{"inlineContent":[{"type":"strong","inlineContent":[{"type":"text","text":"PostgresClientORM"}]},{"type":"text","text":" supports schema migrations. For example:"}],"type":"paragraph"},{"syntax":"swift","code":["func migrate() async throws {","  let migrations = Migrations()","","  try await migrations.add(\"v1\") {","    try await table(\"weather\") {","        column(\"city\", type: .string)","    }","    .create()","  }","","  try await migrations.add(\"v2\") {","    try await table(\"weather) {","        column(\"temp_lo\", type: .double)","        column(\"temp_hi\", type: .double)","    }","    .update()","  }","  ","  try await migrations.perform()","}"],"type":"codeListing"},{"type":"paragraph","inlineContent":[{"type":"text","text":"Columns can have the following modifiers: "},{"code":"drop()","type":"codeVoice"},{"text":", ","type":"text"},{"code":"rename(:)","type":"codeVoice"},{"text":" (arg is new column name), ","type":"text"},{"code":"update(:)","type":"codeVoice"},{"type":"text","text":" (arg is new column type), "},{"type":"codeVoice","code":"defaultValue(:)"},{"type":"text","text":", "},{"type":"codeVoice","code":"unique()"},{"text":", ","type":"text"},{"type":"codeVoice","code":"notNull()"},{"text":", ","type":"text"},{"code":"references(table:column:onDelete:)","type":"codeVoice"},{"type":"text","text":" (is a foreign key referencing anoher table) and "},{"type":"codeVoice","code":"primaryKey()"}]},{"level":3,"type":"heading","anchor":"Transactions","text":"Transactions"},{"inlineContent":[{"text":"It is possible to perform database operations in a database transaction. To perform a transaction:","type":"text"}],"type":"paragraph"},{"syntax":"swift","code":["try await Database.handler.transaction { tid in","    \/\/ perform transaction operations","    \/\/ remember to pass transaction id to any database operation","    var city = try await Weather.fetch(id: city_id, transaction: tid)","    city.temp.lo = -10","    try await city.save(transaction: tid)","}"],"type":"codeListing"},{"inlineContent":[{"type":"text","text":"Its important to pass the transaction Id to database operations in the block, otherwise the app will dead lock. The transaction will appear atomic to other users of the database. If the block terminates normally the transaction is commited. If the block throws the transaction is rolled back."}],"type":"paragraph"}]}],"identifier":{"url":"doc:\/\/PostgresClientORM\/documentation\/PostgresClientORM\/Intro","interfaceLanguage":"swift"},"abstract":[{"type":"text","text":"Welcome to "},{"type":"strong","inlineContent":[{"text":"PostgresClientORM","type":"text"}]},{"type":"text","text":", the "},{"inlineContent":[{"type":"text","text":"ORM"}],"type":"strong"},{"type":"text","text":" for data in "},{"type":"strong","inlineContent":[{"text":"PostgreSQL","type":"text"}]}],"metadata":{"modules":[{"name":"PostgresClientORM"}],"title":"Intro","role":"article","roleHeading":"Article"},"sections":[],"variants":[{"traits":[{"interfaceLanguage":"swift"}],"paths":["\/documentation\/postgresclientorm\/intro"]}],"references":{"doc://PostgresClientORM/documentation/PostgresClientORM/TableObject":{"identifier":"doc:\/\/PostgresClientORM\/documentation\/PostgresClientORM\/TableObject","title":"TableObject","navigatorTitle":[{"kind":"identifier","text":"TableObject"}],"url":"\/documentation\/postgresclientorm\/tableobject","type":"topic","abstract":[],"role":"symbol","fragments":[{"kind":"keyword","text":"protocol"},{"kind":"text","text":" "},{"kind":"identifier","text":"TableObject"}],"kind":"symbol"},"doc://PostgresClientORM/documentation/PostgresClientORM":{"title":"PostgresClientORM","type":"topic","kind":"symbol","role":"collection","url":"\/documentation\/postgresclientorm","identifier":"doc:\/\/PostgresClientORM\/documentation\/PostgresClientORM","abstract":[]}}}